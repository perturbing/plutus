"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[8445],{7980:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>l,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=n(4848),a=n(8453);const o={sidebar_position:10},s="Optimizing Scripts with asData",r={id:"delve-deeper/optimizing-scripts-with-asData",title:"Optimizing Scripts with asData",description:"The Plutus libraries contain a PlutusTx.asData module that contains Template Haskell (TH) code for encoding algebraic data types (ADTs) as Data objects in Plutus Core, as opposed to sums-of-products terms.",source:"@site/docs/delve-deeper/optimizing-scripts-with-asData.md",sourceDirName:"delve-deeper",slug:"/delve-deeper/optimizing-scripts-with-asData",permalink:"/docs/delve-deeper/optimizing-scripts-with-asData",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/doc/docusaurus/docs/delve-deeper/optimizing-scripts-with-asData.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Plutus Tx compiler options",permalink:"/docs/delve-deeper/plutus-tx-compiler-options"},next:{title:"Other Optimization Techniques",permalink:"/docs/delve-deeper/other-optimization-techniques"}},d={},c=[{value:"Purpose",id:"purpose",level:2},{value:"Choice of two approaches",id:"choice-of-two-approaches",level:2},{value:"Approach one: proactively do all of the parsing",id:"approach-one-proactively-do-all-of-the-parsing",level:3},{value:"Approach two: only do the parsing if and when necessary",id:"approach-two-only-do-the-parsing-if-and-when-necessary",level:3},{value:"Using <code>asData</code>",id:"using-asdata",level:2},{value:"Nested fields",id:"nested-fields",level:3},{value:"Choosing an approach",id:"choosing-an-approach",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components},{LiteralInclude:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("LiteralInclude",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.h1,{id:"optimizing-scripts-with-asdata",children:["Optimizing Scripts with ",(0,i.jsx)(t.code,{children:"asData"})]}),"\n",(0,i.jsxs)(t.p,{children:["The Plutus libraries contain a ",(0,i.jsx)(t.code,{children:"PlutusTx.asData"})," module that contains Template Haskell (TH) code for encoding algebraic data types (ADTs) as ",(0,i.jsx)(t.code,{children:"Data"})," objects in Plutus Core, as opposed to sums-of-products terms.\nIn general, ",(0,i.jsx)(t.code,{children:"asData"})," pushes the burden of a computation nearer to where a value is used, in a crude sense making the evaluation less strict and more lazy.\nThis is intended for expert Plutus developers."]}),"\n",(0,i.jsx)(t.h2,{id:"purpose",children:"Purpose"}),"\n",(0,i.jsxs)(t.p,{children:["Values stored in datums or redeemers need to be encoded into ",(0,i.jsx)(t.code,{children:"Data"})," objects.\nWhen writing and optimizing a Plutus script, one of the challenges is finding the right approach to handling ",(0,i.jsx)(t.code,{children:"Data"})," objects and how expensive that method will be.\nTo make an informed decision, you may need to benchmark and profile your smart contract code to measure its actual resource consumption.\nThe primary purpose of ",(0,i.jsx)(t.code,{children:"asData"})," is to give you more options for how you want to handle ",(0,i.jsx)(t.code,{children:"Data"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"choice-of-two-approaches",children:"Choice of two approaches"}),"\n",(0,i.jsxs)(t.p,{children:["When handling ",(0,i.jsx)(t.code,{children:"Data"})," objects, you have a choice of two pathways.\nIt is up to you to determine which pathway to use depending on your particular use case.\nThere are trade offs in performance and where errors occur."]}),"\n",(0,i.jsx)(t.h3,{id:"approach-one-proactively-do-all-of-the-parsing",children:"Approach one: proactively do all of the parsing"}),"\n",(0,i.jsxs)(t.p,{children:["The first approach is to parse the object immediately (using ",(0,i.jsx)(t.code,{children:"fromBuiltinData"}),") into a native Plutus Core datatype, which will also identify any problems with the structuring of the object.\nHowever, this performs all the work up front."]}),"\n",(0,i.jsx)(t.p,{children:"This is the normal style that has been promoted in the past."}),"\n",(0,i.jsx)(t.h3,{id:"approach-two-only-do-the-parsing-if-and-when-necessary",children:"Approach two: only do the parsing if and when necessary"}),"\n",(0,i.jsxs)(t.p,{children:["In the second approach, the script doesn't do any parsing work immediately, and instead does it later, when it needs to.\nIt might be that this saves you a lot of work, because you may never need to parse the entire object.\nInstead, the script will just carry the item around as a ",(0,i.jsx)(t.code,{children:"Data"})," object."]}),"\n",(0,i.jsxs)(t.p,{children:["Using this method, every time the script uses the object, it will look at it to find out if it has the right shape.\nIf it does have the right shape, it will deconstruct the ",(0,i.jsx)(t.code,{children:"Data"})," object and do its processing; if\nnot, it will throw an error.\nThis work may be repeated depending on how your script is written.\nIn some cases, you might do less work, in some cases you might do more work, depending on your specific use case."]}),"\n",(0,i.jsxs)(t.p,{children:["The Plutus Tx library provides some helper functions to make this second style easier to do, in the form of the ",(0,i.jsx)(t.code,{children:"asData"})," function."]}),"\n",(0,i.jsxs)(t.h2,{id:"using-asdata",children:["Using ",(0,i.jsx)(t.code,{children:"asData"})]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"asData"})," function takes the definition of a data type and replaces it with an equivalent definition whose representation uses ",(0,i.jsx)(t.code,{children:"Data"})," directly."]}),"\n",(0,i.jsxs)(t.p,{children:["For example, if we wanted to use it on the types from the ",(0,i.jsx)(t.a,{href:"/docs/auction-smart-contract/on-chain-code",children:"auction example"}),", we would put the datatype declarations inside a Template Haskell quote and call ",(0,i.jsx)(t.code,{children:"asData"})," on it."]}),"\n",(0,i.jsx)(n,{file:"AuctionValidator.hs",language:"haskell",title:"",start:"-- BLOCK9",end:"-- BLOCK10"}),"\n",(0,i.jsxs)(t.p,{children:["This is normal Template Haskell that just generates new Haskell source, so you can see the code that it generates with ",(0,i.jsx)(t.code,{children:"{-# OPTIONS_GHC-ddump-splices #-}"})," but it will look something like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"PlutusTx.asData\n[d| data Bid'\n        = Bid' {bBidder' :: PubKeyHash, bAmount' :: Lovelace}\n        deriving newtype (Eq, Ord, ToBuitinData, FromBuiltinData, UnsafeFromBuiltinData)\n    data AuctionRedeemer' = NewBid' Bid | Payout'\n        deriving newtype (Eq, Ord, ToBuitinData, FromBuiltinData, UnsafeFromBuiltinData) |]\n\n======>\n\nnewtype Bid' = Bid'2 BuiltinData\nderiving newtype (Eq, Ord, PlutusTx.ToData, FromData, UnsafeFromData)\n\n{-# COMPLETE Bid' #-}\npattern Bid' :: PubKeyHash -> Lovelace -> Bid'\npattern Bid' ...\n\nnewtype AuctionRedeemer' = AuctionRedeemer'2 BuiltinData\nderiving newtype (Eq, Ord, PlutusTx.ToData, FromData, UnsafeFromData)\n\n{-# COMPLETE NewBid', Payout' #-}\npattern NewBid' :: Bid -> AuctionRedeemer'\npattern NewBid' ...\npattern Payout' :: AuctionRedeemer'\npattern Payout' ...\n"})}),"\n",(0,i.jsx)(t.p,{children:"That is:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["It creates a newtype wrapper around ",(0,i.jsx)(t.code,{children:"BuiltinData"})]}),"\n",(0,i.jsx)(t.li,{children:"It creates pattern synonyms corresponding to each of the constructors you wrote"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:['This lets you write code "as if" you were using the original declaration that you wrote, while in fact the pattern synonyms are handling conversion to/from ',(0,i.jsx)(t.code,{children:"Data"})," for you.\nBut any values of this type actually are represented with ",(0,i.jsx)(t.code,{children:"Data"}),".\nThat means that when we newtype-derive the instances for converting to and from ",(0,i.jsx)(t.code,{children:"Data"})," we get\nthe instances for ",(0,i.jsx)(t.code,{children:"BuiltinData"})," - which are free!"]}),"\n",(0,i.jsx)(t.h3,{id:"nested-fields",children:"Nested fields"}),"\n",(0,i.jsxs)(t.p,{children:["The most important caveat to using ",(0,i.jsx)(t.code,{children:"asData"})," is that ",(0,i.jsx)(t.code,{children:"Data"})," objects encoding datatypes must also encode the ",(0,i.jsx)(t.em,{children:"fields"})," of the datatype as ",(0,i.jsx)(t.code,{children:"Data"}),".\nHowever, ",(0,i.jsx)(t.code,{children:"asData"})," tries to make the generated code a drop-in replacement for the original code, which means that when using the pattern synonyms they try to give you the fields as they were originally defined, which means ",(0,i.jsx)(t.em,{children:"not"})," encoded as ",(0,i.jsx)(t.code,{children:"Data"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["For example, in the ",(0,i.jsx)(t.code,{children:"Bid"})," case above the ",(0,i.jsx)(t.code,{children:"bAmount"})," field is originally defined to have type ",(0,i.jsx)(t.code,{children:"Lovelace"})," which is a newtype around a Plutus Core builtin integer.\nHowever, since we are using ",(0,i.jsx)(t.code,{children:"asData"}),", we need to encode the field into ",(0,i.jsx)(t.code,{children:"Data"})," in order to store it.\nThat means that when you construct a ",(0,i.jsx)(t.code,{children:"Bid"})," object you must take the ",(0,i.jsx)(t.code,{children:"Integer"})," that you start with and convert it to ",(0,i.jsx)(t.code,{children:"Data"}),", and when you pattern match on a ",(0,i.jsx)(t.code,{children:"Bid"})," object you do the reverse conversion."]}),"\n",(0,i.jsxs)(t.p,{children:["These conversions are potentially expensive!\nIf the ",(0,i.jsx)(t.code,{children:"bAmount"})," field was a complex data structure, then every time we constructed or deconstructed a ",(0,i.jsx)(t.code,{children:"Bid"})," object we would need to convert that datastructure to or from ",(0,i.jsx)(t.code,{children:"Data"}),".\nWhether or not this is a problem depends on the precise situation, but in general:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"If the field is a builtin integer or bytestring or a wrapper around those, it is probably cheap"}),"\n",(0,i.jsxs)(t.li,{children:["If the field is a datatype which is itself defined with ",(0,i.jsx)(t.code,{children:"asData"})," then it is free (since it's already ",(0,i.jsx)(t.code,{children:"Data"}),")"]}),"\n",(0,i.jsx)(t.li,{children:"If the field is a complex or large datatype then it is potentially expensive"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Therefore ",(0,i.jsx)(t.code,{children:"asData"})," tends to work best when you use it for a type and also for all the types of its fields."]}),"\n",(0,i.jsx)(t.h2,{id:"choosing-an-approach",children:"Choosing an approach"}),"\n",(0,i.jsx)(t.p,{children:"There are a number of tradeoffs to consider:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Plutus Tx's datatypes are faster to work with and easier to optimize than ",(0,i.jsx)(t.code,{children:"Data"}),", so if the resulting object is going to be processed in its entirety (or have parts of it repeatedly processed) then it can be better to parse it up-front."]}),"\n",(0,i.jsx)(t.li,{children:"If it is important to check that the entire structure is well-formed, then it is better to parse it up-front, since the conversion will check the entire structure for well-formedness immediately, rather than checking only the parts that are used when they are used."}),"\n",(0,i.jsxs)(t.li,{children:["If you do not want to use ",(0,i.jsx)(t.code,{children:"asData"})," for the types of the fields, then it may be better to not use it at all in order to avoid conversion penalties at the use sites."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Which approach is better is an empirical question and may vary in different cases.\nA single script may wish to use different approaches in different places.\nFor example, your datum might contain a large state object which is usually only inspected in part (a good candidate for ",(0,i.jsx)(t.code,{children:"asData"}),"), whereas your redeemer might be a small object which is inspected frequently to determine what to do (a good candidate for a native Plutus Tx datatype)."]})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(6540);const a={},o=i.createContext(a);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);