"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[135],{8278:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var n=i(4848),o=i(8453);const s={sidebar_position:5},a="On-chain Code: The Auction Validator",r={id:"auction-smart-contract/on-chain-code",title:"On-chain Code: The Auction Validator",description:"The code in this example is not a production-ready implementation, as it is not optimized for security or efficiency.",source:"@site/docs/auction-smart-contract/on-chain-code.md",sourceDirName:"auction-smart-contract",slug:"/auction-smart-contract/on-chain-code",permalink:"/docs/auction-smart-contract/on-chain-code",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/doc/docusaurus/docs/auction-smart-contract/on-chain-code.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Example: An Auction Smart Contract",permalink:"/docs/category/example-an-auction-smart-contract"},next:{title:"End to end",permalink:"/docs/category/end-to-end"}},d={},c=[{value:"Data types",id:"data-types",level:2},{value:"1. Contract parameters",id:"1-contract-parameters",level:3},{value:"2. Datum",id:"2-datum",level:3},{value:"3. Redeemer",id:"3-redeemer",level:3},{value:"4. Script context",id:"4-script-context",level:3},{value:"Main Validator Function",id:"main-validator-function",level:2},{value:"Sufficient Bid Condition",id:"sufficient-bid-condition",level:3},{value:"Valid Bid Time Condition",id:"valid-bid-time-condition",level:3},{value:"Refunds Previous Highest Bid Condition",id:"refunds-previous-highest-bid-condition",level:3},{value:"Correct Output Condition",id:"correct-output-condition",level:3},{value:"Compiling the validator",id:"compiling-the-validator",level:3}];function l(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{LiteralInclude:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("LiteralInclude",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"on-chain-code-the-auction-validator",children:"On-chain Code: The Auction Validator"}),"\n",(0,n.jsx)(t.admonition,{type:"caution",children:(0,n.jsxs)(t.p,{children:["The code in this example is not a production-ready implementation, as it is not optimized for security or efficiency.\nIt is provided purely as an example for illustration and educational purposes.\nRefer to resources like ",(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://library.mlabs.city/common-plutus-security-vulnerabilities",children:"Cardano Plutus Script Vulnerability Guide"})})," for best practices on developing secure smart contracts."]})}),"\n",(0,n.jsx)(t.h1,{id:"auction-properties",children:"Auction Properties"}),"\n",(0,n.jsx)(t.p,{children:"In this example, a seller wants to auction some asset she owns, represented as a non-fungible token (NFT) on Cardano.\nShe would like to create and deploy an auction smart contract with the following properties:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"there is a minimum bid amount"}),"\n",(0,n.jsx)(t.li,{children:"each bid must be higher than the previous highest bid (if any)"}),"\n",(0,n.jsx)(t.li,{children:"once a new bid is made, the previous highest bid (if exists) is immediately refunded"}),"\n",(0,n.jsx)(t.li,{children:"there is a deadline for placing bids; once the deadline has passed, new bids are no longer accepted, the asset can be transferred to the highest bidder (or to the seller if there are no bids), and the highest bid (if exists) can be transferred to the seller."}),"\n"]}),"\n",(0,n.jsx)(t.h1,{id:"plutus-tx-code",children:"Plutus Tx Code"}),"\n",(0,n.jsxs)(t.p,{children:["Plutus Tx is a subset of Haskell, used to write on-chain code, also known as validators or scripts.\nA Plutus Tx program is compiled into Plutus Core, which is interpreted on-chain.\nThe full Plutus Tx code for the auction smart contract can be found at ",(0,n.jsx)(t.a,{href:"https://github.com/IntersectMBO/plutus-tx-template/blob/main/src/AuctionValidator.hs",children:"AuctionValidator.hs"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"data-types",children:"Data types"}),"\n",(0,n.jsx)(t.p,{children:"First, let's define the following data types and instances for the validator:"}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Data types",start:"-- BLOCK1",end:"-- BLOCK2"}),"\n",(0,n.jsxs)(t.p,{children:["The purpose of ",(0,n.jsx)(t.code,{children:"makeLift"})," and ",(0,n.jsx)(t.code,{children:"makeIsDataSchemaIndexed"})," will be explained later."]}),"\n",(0,n.jsx)(t.p,{children:"Writing a Plutus Tx validator script for a smart contract often involves the following data types:"}),"\n",(0,n.jsx)(t.h3,{id:"1-contract-parameters",children:"1. Contract parameters"}),"\n",(0,n.jsxs)(t.p,{children:["These are fixed properties of the contract. You can put here values that will never change during the contract's life cycle.\nIn our example, it is the ",(0,n.jsx)(t.code,{children:"AuctionParams"})," type, containing properties like seller and minimum bid."]}),"\n",(0,n.jsx)(t.h3,{id:"2-datum",children:"2. Datum"}),"\n",(0,n.jsxs)(t.p,{children:["This is part of a script UTXO.\nIt's commonly used to hold the state of the contract and values that can change throughout the contract's life cycle.\nOur example requires only one piece of state: the current highest bid.\nWe use the ",(0,n.jsx)(t.code,{children:"AuctionDatum"})," type to represent this."]}),"\n",(0,n.jsx)(t.h3,{id:"3-redeemer",children:"3. Redeemer"}),"\n",(0,n.jsxs)(t.p,{children:["This is an input to the Plutus script provided by the transaction that is trying to spend a script UTXO.\nIf a smart contract is regarded as a state machine, the redeemer would be the input that ticks the state machine.\nIn our example, it is the ",(0,n.jsx)(t.code,{children:"AuctionRedeemer"})," type: one may either submit a new bid, or request to close the auction and pay out the winner and the seller, both of which lead to a new state of the auction."]}),"\n",(0,n.jsx)(t.h3,{id:"4-script-context",children:"4. Script context"}),"\n",(0,n.jsx)(t.p,{children:"This type contains the information of the transaction that the validator can inspect.\nIn our example, our validator verifies several conditions of the transaction; e.g., if it is a new bid, then it must be submitted before the auction's end time; the previous highest bid must be refunded to the previous bidder, etc."}),"\n",(0,n.jsxs)(t.p,{children:["Different ",(0,n.jsx)(t.a,{href:"/docs/working-with-scripts/ledger-language-version",children:"ledger language versions"})," use different script context types.\nIn this example we are writing a Plutus V2 scripts, so we import the ",(0,n.jsx)(t.code,{children:"ScriptContext"})," data type from ",(0,n.jsx)(t.code,{children:"PlutusLedgerApi.V2.Contexts"}),".\nIt can be easily adapted for Plutus V1 or V3."]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:["\ud83d\udccc"," ",(0,n.jsx)(t.strong,{children:"NOTE"})]}),"\n",(0,n.jsxs)(t.p,{children:["When writing a Plutus validator using Plutus Tx, it is advisable to turn off Haskell's ",(0,n.jsx)(t.code,{children:"Prelude"}),".\nUsage of most functions and methods in ",(0,n.jsx)(t.code,{children:"Prelude"})," should be replaced by their counterparts in the ",(0,n.jsx)(t.code,{children:"plutus-tx"})," library, e.g., instead of the ",(0,n.jsx)(t.code,{children:"=="})," from ",(0,n.jsx)(t.code,{children:"base"}),", use ",(0,n.jsx)(t.code,{children:"PlutusTx.Eq.=="}),"."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"main-validator-function",children:"Main Validator Function"}),"\n",(0,n.jsx)(t.p,{children:"Now we are ready to introduce our main validator function.\nThe beginning of the function looks like the following:"}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Main validator function",start:"-- BLOCK2",end:"-- BLOCK3"}),"\n",(0,n.jsx)(t.p,{children:"Depending on whether this transaction is attempting to submit a new bid or to request payout, the validator validates the corresponding set of conditions."}),"\n",(0,n.jsx)(t.h3,{id:"sufficient-bid-condition",children:"Sufficient Bid Condition"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"sufficientBid"})," condition verifies that the bid amount is sufficient:"]}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Sufficient bid condition",start:"-- BLOCK3",end:"-- BLOCK4"}),"\n",(0,n.jsx)(t.h3,{id:"valid-bid-time-condition",children:"Valid Bid Time Condition"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"validBidTime"})," condition verifies that the bid is submitted before the auction's deadline:"]}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Valid bid time condition",start:"-- BLOCK4",end:"-- BLOCK5"}),"\n",(0,n.jsxs)(t.p,{children:["Here, ",(0,n.jsx)(t.code,{children:"to x"})," is the time interval ending at ",(0,n.jsx)(t.code,{children:"x"}),", i.e., ",(0,n.jsx)(t.code,{children:"(-\u221e, x]"}),".\n",(0,n.jsx)(t.code,{children:"txInfoValidRange"})," is a transaction property.\nIt is the time interval in which the transaction is allowed to go through phase-1 validation.\n",(0,n.jsx)(t.code,{children:"contains"})," takes two time intervals, and checks that the first interval completely includes the second.\nSince the transaction may be validated at any point in the ",(0,n.jsx)(t.code,{children:"txInfoValidRange"})," interval, we need to check that the entire interval lies within ",(0,n.jsx)(t.code,{children:"(-\u221e, apEndTime params]"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["The reason a script receives the ",(0,n.jsx)(t.code,{children:"txInfoValidRange"})," interval instead of the exact time the script is run is due to ",(0,n.jsx)(t.a,{href:"https://iohk.io/en/blog/posts/2021/09/06/no-surprises-transaction-validation-on-cardano/",children:"determinism"}),".\nUsing the exact time would be like calling a ",(0,n.jsx)(t.code,{children:"getCurrentTime"})," function and branching based on the current time.\nOn the other hand, by using the ",(0,n.jsx)(t.code,{children:"txInfoValidRange"})," interval, the same interval is always used by the same transaction.\nIf the current time when the transaction is validated is outside of the interval, the transaction is rejected immediately without running the script."]}),"\n",(0,n.jsxs)(t.p,{children:["Also note the tilde (",(0,n.jsx)(t.code,{children:"~"}),") in ",(0,n.jsx)(t.code,{children:"~validBidTime = ..."}),".\nWhen writing Plutus Tx it is ",(0,n.jsx)(t.a,{href:"/docs/using-plutus-tx/compiling-plutus-tx",children:"advisable"})," to turn on the ",(0,n.jsx)(t.code,{children:"Strict"})," extension, which generally improves script performance.\nDoing so makes all bindings strict, which means, in this particular case, without the ",(0,n.jsx)(t.code,{children:"~"}),", ",(0,n.jsx)(t.code,{children:"validBidTime"})," would be evaluated even if the redeemer matches the ",(0,n.jsx)(t.code,{children:"Payout"})," case, which doesn't need this condition.\nDoing so results in unnecessary work or even unexpected evaluation failures.\nThe ",(0,n.jsx)(t.code,{children:"~"})," makes ",(0,n.jsx)(t.code,{children:"validBidTime"})," non-strict, i.e., only evaluated when used."]}),"\n",(0,n.jsxs)(t.p,{children:["On the other hand, it is unnecessary to add ",(0,n.jsx)(t.code,{children:"~"})," to ",(0,n.jsx)(t.code,{children:"sufficientBid"}),", since it has a function type, and a function cannot be evaluated further without receiving enough arguments."]}),"\n",(0,n.jsx)(t.h3,{id:"refunds-previous-highest-bid-condition",children:"Refunds Previous Highest Bid Condition"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"refundsPreviousHighestBid"})," condition checks that the transaction pays the previous highest bid to the previous bidder:"]}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Refunds previous highest bid condition",start:"-- BLOCK5",end:"-- BLOCK6"}),"\n",(0,n.jsxs)(t.p,{children:["It uses ",(0,n.jsx)(t.code,{children:"PlutusTx.find"})," to find the transaction output (a UTXO) that pays to the previous bidder the amount equivalent to the previous highest bid, and verifies that there is at least one such output."]}),"\n",(0,n.jsx)(t.h3,{id:"correct-output-condition",children:"Correct Output Condition"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"correctOutput"})," condition verifies that the transaction produces a ",(0,n.jsx)(t.em,{children:"continuing output"})," (see below for definition) containing the correct datum and value.\nIt has two subconditions:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"correctOutputDatum"}),": the datum should contain the new highest bid"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"correctOutputValue"}),": the value should contain (1) the token being auctioned, and (2) the bid amount."]}),"\n"]}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Correct new datum condition",start:"-- BLOCK6",end:"-- BLOCK7"}),"\n",(0,n.jsx)(t.p,{children:'A "continuing output" is a transaction output that pays to the same script address from which we are currently spending.\nExactly one continuing output must be present in this example so that the next bidder can place a new bid.\nThe new bid, in turn, will need to spend the continuing output and get validated by the same script.'}),"\n",(0,n.jsxs)(t.p,{children:["If the transaction is requesting a payout, the validator will then verify the other three conditions: ",(0,n.jsx)(t.code,{children:"validPayoutTime"}),", ",(0,n.jsx)(t.code,{children:"sellerGetsHighestBid"})," and ",(0,n.jsx)(t.code,{children:"highestBidderGetsAsset"}),".\nThese conditions are similar to the ones already explained, so their details are omitted."]}),"\n",(0,n.jsx)(t.h3,{id:"compiling-the-validator",children:"Compiling the validator"}),"\n",(0,n.jsx)(t.p,{children:"Finally, we need to compile the validator written in Plutus Tx into Plutus Core, using the Plutus Tx compiler:"}),"\n",(0,n.jsx)(i,{file:"AuctionValidator.hs",language:"haskell",title:"Compiling the validator",start:"-- BLOCK8",end:"-- BLOCK9"}),"\n",(0,n.jsxs)(t.p,{children:["The type of a compiled Plutus V2 spending validator should be ",(0,n.jsx)(t.code,{children:"CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> BuiltinUnit)"}),", as explained in ",(0,n.jsx)(t.a,{href:"/docs/working-with-scripts/ledger-language-version",children:"Plutus Ledger Language Version"}),".\nThe call to ",(0,n.jsx)(t.code,{children:"PlutusTx.unsafeFromBuiltinData"})," is the reason we need the ",(0,n.jsx)(t.code,{children:"PlutusTx.unstableMakeIsData"})," shown before, which derives ",(0,n.jsx)(t.code,{children:"UnsafeFromData"})," instances.\nAnd instead of returning a ",(0,n.jsx)(t.code,{children:"Bool"}),", it simply returns ",(0,n.jsx)(t.code,{children:"()"}),", and the validation succeeds if the script evaluates without error."]}),"\n",(0,n.jsxs)(t.p,{children:["Note that ",(0,n.jsx)(t.code,{children:"AuctionParams"})," is ",(0,n.jsx)(t.em,{children:"not"})," an argument of the compiled validator.\n",(0,n.jsx)(t.code,{children:"AuctionParams"})," contains contract properties that don't change, so it is simply built into the validator by partial application.\nThe partial application is done via ",(0,n.jsx)(t.code,{children:"PlutusTx.unsafeApplyCode"}),"."]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:["\ud83d\udccc"," ",(0,n.jsx)(t.strong,{children:"NOTE"})]}),"\n",(0,n.jsxs)(t.p,{children:["It is worth noting that we must call ",(0,n.jsx)(t.code,{children:"PlutusTx.compile"})," on the entire ",(0,n.jsx)(t.code,{children:"auctionUntypedValidator"}),", rather than applying it to ",(0,n.jsx)(t.code,{children:"params"})," before compiling, as in ",(0,n.jsx)(t.code,{children:"$$(PlutusTx.compile [||auctionUntypedValidator params||])"}),".\nThe latter won't work, because everything being compiled (inside ",(0,n.jsx)(t.code,{children:"[||...||]"}),") must be known at compile time, but we won't be able to access ",(0,n.jsx)(t.code,{children:"params"})," until runtime.\nInstead, once we have the ",(0,n.jsx)(t.code,{children:"params"})," at runtime, we use ",(0,n.jsx)(t.code,{children:"liftCode"})," to lift it into a Plutus Core term before calling ",(0,n.jsx)(t.code,{children:"unsafeApplyCode"}),".\nThis is the reason why we need the ",(0,n.jsx)(t.code,{children:"Lift"})," instance for ",(0,n.jsx)(t.code,{children:"AuctionParams"}),", derived via ",(0,n.jsx)(t.code,{children:"PlutusTx.makeLift"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>r});var n=i(6540);const o={},s=n.createContext(o);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);