"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9724],{3031:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var s=n(4848),t=n(8453);const r={sidebar_position:15},o="Other Optimization Techniques",a={id:"delve-deeper/other-optimization-techniques",title:"Other Optimization Techniques",description:"Identifying problem areas",source:"@site/docs/delve-deeper/other-optimization-techniques.md",sourceDirName:"delve-deeper",slug:"/delve-deeper/other-optimization-techniques",permalink:"/docs/delve-deeper/other-optimization-techniques",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/doc/docusaurus/docs/delve-deeper/other-optimization-techniques.md",tags:[],version:"current",sidebarPosition:15,frontMatter:{sidebar_position:15},sidebar:"tutorialSidebar",previous:{title:"Optimizing Scripts with asData",permalink:"/docs/delve-deeper/optimizing-scripts-with-asData"},next:{title:"Understanding Script Hashes",permalink:"/docs/delve-deeper/understanding-script-hashes"}},l={},c=[{value:"Identifying problem areas",id:"identifying-problem-areas",level:2},{value:"Using a Recent Version of the Plutus Tx Compiler",id:"using-a-recent-version-of-the-plutus-tx-compiler",level:2},{value:"Try <code>conservative-optimisation</code> or Flags Implied by It",id:"try-conservative-optimisation-or-flags-implied-by-it",level:2},{value:"Using the <code>Strict</code> Extension",id:"using-the-strict-extension",level:2},{value:"Avoiding the <code>INLINE</code> Pragma",id:"avoiding-the-inline-pragma",level:2},{value:"Be Mindful of Strict Applications",id:"be-mindful-of-strict-applications",level:2},{value:"Avoiding Intermediate Results",id:"avoiding-intermediate-results",level:2},{value:"Specializing higher-order functions",id:"specializing-higher-order-functions",level:2},{value:"Removing Traces",id:"removing-traces",level:2},{value:"Using <code>error</code> for faster failure",id:"using-error-for-faster-failure",level:2}];function d(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.h1,{id:"other-optimization-techniques",children:"Other Optimization Techniques"}),"\n",(0,s.jsx)(i.h2,{id:"identifying-problem-areas",children:"Identifying problem areas"}),"\n",(0,s.jsxs)(i.p,{children:["Profiling your script is a good way  to identify which parts of the script are responsible for significant resource consumption.\nFor more details, see ",(0,s.jsx)(i.a,{href:"/docs/working-with-scripts/profiling-budget-usage",children:"Profiling the Budget Usage of Plutus Scripts"}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"using-a-recent-version-of-the-plutus-tx-compiler",children:"Using a Recent Version of the Plutus Tx Compiler"}),"\n",(0,s.jsxs)(i.p,{children:["The Plutus Tx compiler is available through the ",(0,s.jsx)(i.code,{children:"plutus-tx-plugin"})," package.\nThe Plutus team continuously improves compiler optimization, so using the latest or a recent version of ",(0,s.jsx)(i.code,{children:"plutus-tx-plugin"})," will likely result in more compact and efficient scripts."]}),"\n",(0,s.jsxs)(i.h2,{id:"try-conservative-optimisation-or-flags-implied-by-it",children:["Try ",(0,s.jsx)(i.code,{children:"conservative-optimisation"})," or Flags Implied by It"]}),"\n",(0,s.jsxs)(i.p,{children:["Certain optimizations, such as inlining constants, can occasionally have negative effects, making scripts larger or more expensive.\nIt is worth disabling them to see how it affects your script.\nYou can do this using the ",(0,s.jsx)(i.code,{children:"conservative-optimisation"})," plugin flag, which implies several other flags like ",(0,s.jsx)(i.code,{children:"no-inline-constants"}),".\nAlternatively, try turning on the flags implied by ",(0,s.jsx)(i.code,{children:"conservative-optimisation"})," individually.\nSee ",(0,s.jsx)(i.a,{href:"/docs/delve-deeper/plutus-tx-compiler-options",children:"Plutus Tx Compiler Options"}),"."]}),"\n",(0,s.jsxs)(i.h2,{id:"using-the-strict-extension",children:["Using the ",(0,s.jsx)(i.code,{children:"Strict"})," Extension"]}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"Strict"})," extension, which makes all bindings in a module strict, generally improves performance.\nSee ",(0,s.jsx)(i.a,{href:"/docs/using-plutus-tx/extensions-flags-pragmas",children:"GHC Extensions, Flags and Pragmas"})," for an explanation.\nHowever, care should be taken to avoid triggering unnecessary evaluations.\nFor example, in"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-haskell",children:"let a = <expr1>\n    b = <expr2>\n in a && b\n"})}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"b"})," will always be evaluated, even when ",(0,s.jsx)(i.code,{children:"a"})," evaluates to ",(0,s.jsx)(i.code,{children:"False"}),".\nTo avoid this, you can write either ",(0,s.jsx)(i.code,{children:"~b = <expr2>"}),", or ",(0,s.jsx)(i.code,{children:"a && <expr2>"})," (recall that ",(0,s.jsx)(i.code,{children:"&&"})," and ",(0,s.jsx)(i.code,{children:"||"})," are ",(0,s.jsx)(i.a,{href:"/docs/using-plutus-tx/special-functions-and-types",children:"special"})," in Plutus Tx in that their second arguments are non-strict, unlike ordinary Plutus Tx functions).\nHowever, keep in mind that with ",(0,s.jsx)(i.code,{children:"~b = <expr2>"}),", ",(0,s.jsx)(i.code,{children:"<expr2>"})," will be evaluated each time ",(0,s.jsx)(i.code,{children:"b"})," is referenced, since Plutus Tx does not employ lazy evaluation, i.e., there is no memoization."]}),"\n",(0,s.jsxs)(i.h2,{id:"avoiding-the-inline-pragma",children:["Avoiding the ",(0,s.jsx)(i.code,{children:"INLINE"})," Pragma"]}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"INLINE"})," pragma strongly encourages GHC to inline a function, even if it has a large body and is used multiple times.\nThis can lead to significant increase in the size of the resulting UPLC program, which is problematic since size is a much scarcer resource for Plutus scripts than for regular Haskell programs."]}),"\n",(0,s.jsxs)(i.p,{children:["Instead, use the ",(0,s.jsx)(i.code,{children:"INLINEABLE"})," pragma.\nThis would leave most inlining decisions to the PIR and UPLC inliners, which are tailored for Plutus scripts and make more informed inlining decisions."]}),"\n",(0,s.jsx)(i.h2,{id:"be-mindful-of-strict-applications",children:"Be Mindful of Strict Applications"}),"\n",(0,s.jsxs)(i.p,{children:["In Plutus Tx, as with all strict languages, function applications are strict (call by value), with the exception of a few special functions like ",(0,s.jsx)(i.code,{children:"&&"})," and ",(0,s.jsx)(i.code,{children:"||"}),", which are treated specially by the compiler."]}),"\n",(0,s.jsxs)(i.p,{children:["If you define your own version of ",(0,s.jsx)(i.code,{children:"&&"}),":"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-haskell",children:"myAnd :: Bool -> Bool -> Bool\nmyAnd = (&&)\n"})}),"\n",(0,s.jsxs)(i.p,{children:["then it won't have the same behavior as ",(0,s.jsx)(i.code,{children:"&&"}),", as it will always evaluate both arguments, even if the first argument evaluates to ",(0,s.jsx)(i.code,{children:"False"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["It is particularly important to recognize that builtin functions like ",(0,s.jsx)(i.code,{children:"chooseList"})," and ",(0,s.jsx)(i.code,{children:"chooseData"})," are ",(0,s.jsx)(i.em,{children:"not"})," special, i.e., they are also strict in all arguments.\nThus the following example, which directly invokes the ",(0,s.jsx)(i.code,{children:"chooseList"})," builtin, can be inefficient:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-haskell",children:"res = PlutusTx.Builtins.Internal.chooseList xs nilCase consCase\n"})}),"\n",(0,s.jsxs)(i.p,{children:["It may even be semantically incorrect, if ",(0,s.jsx)(i.code,{children:'nilCase = traceError "empty list"'}),", since it would always evaluate to an error."]}),"\n",(0,s.jsxs)(i.p,{children:["Instead, use the wrapper provided by ",(0,s.jsx)(i.code,{children:"PlutusTx.Builtins"}),", which suspends the evaluation of ",(0,s.jsx)(i.code,{children:"nilCase"})," with a lambda:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-haskell",children:"res = PlutusTx.Builtins.matchList (\\_ -> nilCase) consCase\n"})}),"\n",(0,s.jsx)(i.h2,{id:"avoiding-intermediate-results",children:"Avoiding Intermediate Results"}),"\n",(0,s.jsx)(i.p,{children:"In a strict language, when composing several operations on a structure, the intermediate results are often fully materialized.\nAs examples, consider"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-haskell",children:"res1 = find (== 5) (xs ++ ys)\n"})}),"\n",(0,s.jsx)(i.p,{children:"and"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-haskell",children:"res2 = sum (Map.elems m)\n"})}),"\n",(0,s.jsxs)(i.p,{children:["These are perfectly efficient in Haskell, but since function applications are strict in Plutus Tx, the results of ",(0,s.jsx)(i.code,{children:"xs ++ ys"})," and ",(0,s.jsx)(i.code,{children:"Map.elems m"})," will be fully materialized before invoking ",(0,s.jsx)(i.code,{children:"find"})," and ",(0,s.jsx)(i.code,{children:"sum"}),", respectively.\nYou might consider rewriting these expressions to be less succinct but more efficient."]}),"\n",(0,s.jsx)(i.h2,{id:"specializing-higher-order-functions",children:"Specializing higher-order functions"}),"\n",(0,s.jsx)(i.p,{children:"The use of higher-order functions is a common technique to facilitate code reuse.\nHigher-order functions are widely used in the Plutus libraries but can be less efficient than specialized versions."}),"\n",(0,s.jsxs)(i.p,{children:["For instance, the Plutus function ",(0,s.jsx)(i.code,{children:"findOwnInput"})," makes use of the higher-order function ",(0,s.jsx)(i.code,{children:"find"})," to search for the current script input."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-haskell",children:"findOwnInput :: ScriptContext -> Maybe TxInInfo\nfindOwnInput ScriptContext{scriptContextTxInfo=TxInfo{txInfoInputs},\n             scriptContextPurpose=Spending txOutRef} =\n    find (\\TxInInfo{txInInfoOutRef} -> txInInfoOutRef == txOutRef) txInfoInputs\nfindOwnInput _ = Nothing\n"})}),"\n",(0,s.jsx)(i.p,{children:"This can be rewritten with a recursive function specialized to the specific check in question."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-haskell",children:"findOwnInput :: ScriptContext -> Maybe TxInInfo\nfindOwnInput ScriptContext{scriptContextTxInfo=TxInfo{txInfoInputs},\n             scriptContextPurpose=Spending txOutRef} = go txInfoInputs\n    where\n        go [] = Nothing\n        go (i@TxInInfo{txInInfoOutRef} : rest) = if txInInfoOutRef == txOutRef\n                                                 then Just i\n                                                 else go rest\nfindOwnInput _ = Nothing\n"})}),"\n",(0,s.jsx)(i.h2,{id:"removing-traces",children:"Removing Traces"}),"\n",(0,s.jsxs)(i.p,{children:["Traces can be expensive especially in terms of script sizes.\nIt is advisable to use traces during development, but to remove them when deploying your scripts on mainnet.\nTraces can be removed via the ",(0,s.jsx)(i.code,{children:"remove-trace"})," plugin flag."]}),"\n",(0,s.jsxs)(i.h2,{id:"using-error-for-faster-failure",children:["Using ",(0,s.jsx)(i.code,{children:"error"})," for faster failure"]}),"\n",(0,s.jsxs)(i.p,{children:["Plutus scripts have access to one impure effect, ",(0,s.jsx)(i.code,{children:"error"}),", which immediately terminates the script evaluation and will fail validation.\nThis failure is very fast, but it is also unrecoverable, so only use it in cases where you want to fail the entire validation if there is a failure."]}),"\n",(0,s.jsxs)(i.p,{children:["The Plutus libraries have some functions that fail with ",(0,s.jsx)(i.code,{children:"error"}),".\nUsually these are given an ",(0,s.jsx)(i.code,{children:"unsafe"})," prefix to their name.\nFor example, ",(0,s.jsx)(i.code,{children:"PlutusTx.IsData.Class.FromData"})," parses a value of type ",(0,s.jsx)(i.code,{children:"Data"}),", returning the result in a ",(0,s.jsx)(i.code,{children:"Maybe"})," value to indicate whether it succeeded or failed; whereas ",(0,s.jsx)(i.code,{children:"PlutusTx.IsData.Class.UnsafeFromData"})," does the same but fails with ",(0,s.jsx)(i.code,{children:"error"}),"."]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var s=n(6540);const t={},r=s.createContext(t);function o(e){const i=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);