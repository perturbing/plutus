"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[8947],{2606:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var n=s(4848),i=s(8453);const l={sidebar_position:15},r="Differences From Haskell",o={id:"using-plutus-tx/differences-from-haskell",title:"Differences From Haskell",description:"Strictness",source:"@site/docs/using-plutus-tx/differences-from-haskell.md",sourceDirName:"using-plutus-tx",slug:"/using-plutus-tx/differences-from-haskell",permalink:"/docs/using-plutus-tx/differences-from-haskell",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/doc/docusaurus/docs/using-plutus-tx/differences-from-haskell.md",tags:[],version:"current",sidebarPosition:15,frontMatter:{sidebar_position:15},sidebar:"tutorialSidebar",previous:{title:"Compiling Plutus Tx",permalink:"/docs/using-plutus-tx/compiling-plutus-tx"},next:{title:"GHC Extensions, Flags and Pragmas",permalink:"/docs/using-plutus-tx/extensions-flags-pragmas"}},a={},c=[{value:"Strictness",id:"strictness",level:2},{value:"Function Applications",id:"function-applications",level:3},{value:"Bindings",id:"bindings",level:3},{value:"Supported Haskell Features",id:"supported-haskell-features",level:2}];function u(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"differences-from-haskell",children:"Differences From Haskell"}),"\n",(0,n.jsx)(t.h2,{id:"strictness",children:"Strictness"}),"\n",(0,n.jsx)(t.h3,{id:"function-applications",children:"Function Applications"}),"\n",(0,n.jsxs)(t.p,{children:["Unlike in Haskell, function applications in Plutus Tx are strict.\nIn other words, when evaluating ",(0,n.jsx)(t.code,{children:"(\\x -> 42) (3 + 4)"})," the expression ",(0,n.jsx)(t.code,{children:"3 + 4"})," is evaluated first, before evaluating the function body (",(0,n.jsx)(t.code,{children:"42"}),"), even though ",(0,n.jsx)(t.code,{children:"x"})," is not used in the function body."]}),"\n",(0,n.jsxs)(t.p,{children:["Using lazy patterns on function parameters does not change this behavior: : ",(0,n.jsx)(t.code,{children:"(\\(~x) -> 42) (3 + 4)"})," still evaluates ",(0,n.jsx)(t.code,{children:"3 + 4"})," strictly.\nAt this time, it is not possible to make function applications non-strict in Plutus Tx."]}),"\n",(0,n.jsx)(t.h3,{id:"bindings",children:"Bindings"}),"\n",(0,n.jsxs)(t.p,{children:["Bindings in Plutus Tx are by default non-strict, but they can be made strict via the bang pattern (",(0,n.jsx)(t.code,{children:"!"}),"), as in ",(0,n.jsx)(t.code,{children:"let !x = 3 + 4 in 42"}),".\nConversely, in modules with the ",(0,n.jsx)(t.code,{children:"Strict"})," language extension on, bindings are by default strict, but they can be made non-strict via the lazy pattern (",(0,n.jsx)(t.code,{children:"~"}),"), as in ",(0,n.jsx)(t.code,{children:"let ~x = 3 + 4 in 42"}),"."]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:["\ud83d\udccc"," ",(0,n.jsx)(t.strong,{children:"NOTE"})]}),"\n",(0,n.jsx)(t.p,{children:"It is important to note that the UPLC evaluator does not perform lazy evaluation, which means a non-strict binding will be evaluated each time it is used, rather than at most once."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"supported-haskell-features",children:"Supported Haskell Features"}),"\n",(0,n.jsx)(t.p,{children:"The Plutus Tx compiler provides good support for basic Haskell features, including regular algebraic data types, type classes, higher order functions, parametric polymorphism, etc.\nHowever, it doesn\u2019t support many of Haskell\u2019s more advanced features.\nA good rule of thumb for writing Plutus Tx is to stick with simple Haskell (which is also typically good advice for Haskell development in general)."}),"\n",(0,n.jsxs)(t.p,{children:["Some notable Haskell features ",(0,n.jsx)(t.em,{children:"not"})," supported by Plutus Tx include:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Many functions and methods in ",(0,n.jsx)(t.a,{href:"https://hackage.haskell.org/package/base",children:(0,n.jsx)(t.code,{children:"base"})}),".\nUse the counterparts in the ",(0,n.jsx)(t.a,{href:"https://plutus.cardano.intersectmbo.org/haddock/latest/plutus-tx/",children:(0,n.jsx)(t.code,{children:"plutus-tx"})})," library instead.\nThis also means most Haskell third-party libraries are not supported, unless the library is developed specifically for Plutus Tx."]}),"\n",(0,n.jsx)(t.li,{children:"Mutually recursive data types."}),"\n",(0,n.jsx)(t.li,{children:"Type families"}),"\n",(0,n.jsx)(t.li,{children:"Existential types"}),"\n",(0,n.jsx)(t.li,{children:"GADTs"}),"\n",(0,n.jsx)(t.li,{children:"IO and FFI"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:'Use of these features often leads the Plutus Tx compiler to report an "Unsupported feature" error, though you may sometimes get a different error.'}),"\n",(0,n.jsx)(t.p,{children:"Since the Plutus Tx compiler is a GHC plugin that runs after GHC's type checking, unsupported Haskell features cannot be detected at type checking time.\nAs a result, it's unlikely that an IDE will be able to report these errors.\nYou will need to compile the Haskell module to determine if everything is compiled successfully."})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>o});var n=s(6540);const i={},l=n.createContext(i);function r(e){const t=n.useContext(l);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(l.Provider,{value:t},e.children)}}}]);