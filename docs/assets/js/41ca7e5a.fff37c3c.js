"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[3736],{2385:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var i=t(4848),r=t(8453);const a={sidebar_position:3},s="Producing a Plutus contract blueprint",l={id:"working-with-scripts/producing-a-blueprint",title:"Producing a Plutus contract blueprint",description:"Plutus contract blueprints (CIP-0057) are used to document the binary interface of a Plutus contract in a machine-readable format (JSON schema).",source:"@site/docs/working-with-scripts/producing-a-blueprint.md",sourceDirName:"working-with-scripts",slug:"/working-with-scripts/producing-a-blueprint",permalink:"/docs/working-with-scripts/producing-a-blueprint",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/doc/docusaurus/docs/working-with-scripts/producing-a-blueprint.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Script Purposes",permalink:"/docs/working-with-scripts/script-purposes"},next:{title:"Profiling the budget usage of Plutus scripts",permalink:"/docs/working-with-scripts/profiling-budget-usage"}},o={},d=[{value:"Demonstrating the usage of the <code>writeBlueprint</code> function",id:"demonstrating-the-usage-of-the-writeblueprint-function",level:2},{value:"Required pragmas and imports",id:"required-pragmas-and-imports",level:2},{value:"Defining a contract blueprint value",id:"defining-a-contract-blueprint-value",level:2},{value:"Example construction",id:"example-construction",level:2},{value:"Defining a validator blueprint",id:"defining-a-validator-blueprint",level:2},{value:"Writing the blueprint to a file",id:"writing-the-blueprint-to-a-file",level:2},{value:"Annotations",id:"annotations",level:2},{value:"Resulting full blueprint example",id:"resulting-full-blueprint-example",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{LiteralInclude:a}=n;return a||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("LiteralInclude",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"producing-a-plutus-contract-blueprint",children:"Producing a Plutus contract blueprint"}),"\n",(0,i.jsxs)(n.p,{children:["Plutus contract blueprints (",(0,i.jsx)(n.a,{href:"https://cips.cardano.org/cip/CIP-0057",children:"CIP-0057"}),") are used to document the binary interface of a Plutus contract in a machine-readable format (JSON schema)."]}),"\n",(0,i.jsxs)(n.p,{children:["A contract blueprint can be produced by using the ",(0,i.jsx)(n.code,{children:"writeBlueprint"})," function exported by the ",(0,i.jsx)(n.code,{children:"PlutusTx.Blueprint"})," module:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"writeBlueprint\n  :: FilePath\n  -- ^ The file path where the blueprint will be written to,\n  --  e.g. '/tmp/plutus.json'\n  -> ContractBlueprint\n  -- ^ Contains all the necessary information to generate\n  -- a blueprint for a Plutus contract.\n  -> IO ()\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"demonstrating-the-usage-of-the-writeblueprint-function",children:["Demonstrating the usage of the ",(0,i.jsx)(n.code,{children:"writeBlueprint"})," function"]}),"\n",(0,i.jsxs)(n.p,{children:["In order to demonstrate the usage of the ",(0,i.jsx)(n.code,{children:"writeBlueprint"})," function, let's consider the following example validator function and its interface:"]}),"\n",(0,i.jsx)(a,{file:"Example/Cip57/Blueprint/Main.hs",language:"haskell",title:"interface types",start:"-- BEGIN interface types",end:"-- END interface types"}),"\n",(0,i.jsx)(a,{file:"Example/Cip57/Blueprint/Main.hs",language:"haskell",title:"validator",start:"-- BEGIN validator",end:"-- END validator"}),"\n",(0,i.jsx)(n.h2,{id:"required-pragmas-and-imports",children:"Required pragmas and imports"}),"\n",(0,i.jsx)(n.p,{children:"First of all, we need to specify required pragmas and import necessary modules:"}),"\n",(0,i.jsx)(a,{file:"Example/Cip57/Blueprint/Main.hs",language:"haskell",title:"pragmas",start:"-- BEGIN pragmas",end:"-- END pragmas"}),"\n",(0,i.jsx)(a,{file:"Example/Cip57/Blueprint/Main.hs",language:"haskell",title:"imports",start:"-- BEGIN imports",end:"-- END imports"}),"\n",(0,i.jsx)(n.h2,{id:"defining-a-contract-blueprint-value",children:"Defining a contract blueprint value"}),"\n",(0,i.jsx)(n.p,{children:"Next, we define a contract blueprint value of the following type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data ContractBlueprint where\n  MkContractBlueprint\n    :: forall referencedTypes\n    . { contractId :: Maybe Text\n        -- ^ An optional identifier for the contract.\n      , contractPreamble :: Preamble\n        -- ^ An object with meta-information about the contract.\n      , contractValidators :: Set (ValidatorBlueprint referencedTypes)\n        -- ^ A set of validator blueprints that are part of the contract.\n      , contractDefinitions :: Definitions referencedTypes\n        -- ^ A registry of schema definitions used across the blueprint.\n      }\n    -> ContractBlueprint\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["\ud83d\udccc"," ",(0,i.jsx)(n.strong,{children:"NOTE"})]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"referencedTypes"})," type parameter is used to track the types used in the contract making sure their schemas are included in the blueprint and that they are referenced in a type-safe way."]}),"\n",(0,i.jsxs)(n.p,{children:["The blueprint will contain JSON schema definitions for all the types used in the contract, including the types ",(0,i.jsx)(n.strong,{children:"nested"})," within the top-level types (",(0,i.jsx)(n.code,{children:"MyParams"}),", ",(0,i.jsx)(n.code,{children:"MyDatum"}),", ",(0,i.jsx)(n.code,{children:"MyRedeemer"}),") recursively."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"We can construct a value of this type in the following way:"}),"\n",(0,i.jsx)(a,{file:"Example/Cip57/Blueprint/Main.hs",language:"haskell",title:"contract blueprint declaration",start:"-- BEGIN contract blueprint declaration",end:"-- END contract blueprint declaration"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"contractId"})," field is optional and can be used to give a unique identifier to the contract."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"contractPreamble"})," field is a value of type ",(0,i.jsx)(n.code,{children:"PlutusTx.Blueprint.Preamble"})," and contains a meta-information\nabout the contract:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data Preamble = MkPreamble\n  { preambleTitle         :: Text\n  -- ^ A short and descriptive title of the contract application\n  , preambleDescription   :: Maybe Text\n  -- ^ A more elaborate description\n  , preambleVersion       :: Text\n  -- ^ A version number for the project.\n  , preamblePlutusVersion :: PlutusVersion\n  -- ^ The Plutus version assumed for all validators\n  , preambleLicense       :: Maybe Text\n  -- ^ A license under which the specification\n  -- and contract code is distributed\n  }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"example-construction",children:"Example construction"}),"\n",(0,i.jsx)(n.p,{children:"Here is an example construction:"}),"\n",(0,i.jsx)(a,{file:"Example/Cip57/Blueprint/Main.hs",language:"haskell",title:"preamble declaration",start:"-- BEGIN preamble declaration",end:"-- END preamble declaration"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"contractDefinitions"})," field is a registry of schema definitions used across the blueprint.\nIt can be constructed using the ",(0,i.jsx)(n.code,{children:"deriveDefinitions"})," function which automatically constructs schema definitions for all the types it is applied to including the types nested within them."]}),"\n",(0,i.jsxs)(n.p,{children:["Since every type in the ",(0,i.jsx)(n.code,{children:"referencedTypes"})," list is going to have its derived JSON-schema in the ",(0,i.jsx)(n.code,{children:"contractDefinitions"})," registry under a certain unique ",(0,i.jsx)(n.code,{children:"DefinitionId"})," key, we need to make sure that it has the following instances:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"instance HasBlueprintDefinition MyType"})," allows to add a ",(0,i.jsx)(n.code,{children:"MyType"})," schema definition to the ",(0,i.jsx)(n.code,{children:"contractDefinitions"})," registry by providing a ",(0,i.jsx)(n.code,{children:"DefinitionId"})," value for ",(0,i.jsx)(n.code,{children:"MyType"}),", e.g. ",(0,i.jsx)(n.code,{children:'"my-type"'}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The good news is that most of the time these instances either already exist (for types defined in the Plutus libraries) or can be derived automatically:"}),"\n",(0,i.jsx)(a,{file:"Example/Cip57/Blueprint/Main.hs",language:"haskell",title:"Generically-derived HasBlueprintDefinition instances",start:"-- BEGIN derived instances",end:"-- END derived instances"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"instance HasBlueprintSchema MyType"})," allows to derive a JSON schema for ",(0,i.jsx)(n.code,{children:"MyType"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Types that are covered by a blueprint are exposed via the validator arguments and therefore must be convertible to/from ",(0,i.jsx)(n.code,{children:"Data"})," representation. The conversion is done using instances of ",(0,i.jsx)(n.code,{children:"ToData"}),", ",(0,i.jsx)(n.code,{children:"FromData"})," and optionally ",(0,i.jsx)(n.code,{children:"UnsafeFromData"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["You probably already have these instances derived with Template Haskell functions ",(0,i.jsx)(n.code,{children:"makeIsDataIndexed"})," or ",(0,i.jsx)(n.code,{children:"unstableMakeIsData"})," which are located in the ",(0,i.jsx)(n.code,{children:"PlutusTx.IsData.TH"})," module. You can add derivation of the\n",(0,i.jsx)(n.code,{children:"HasBlueprintSchema"})," instance very easily:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Replace usages of ",(0,i.jsx)(n.code,{children:"PlutusTx.IsData.TH.makeIsDataIndexed"})," with ",(0,i.jsx)(n.code,{children:"PlutusTx.Blueprint.TH.makeIsDataSchemaIndexed"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Replace usages of ",(0,i.jsx)(n.code,{children:"PlutusTx.IsData.TH.unstableMakeIsData"})," with ",(0,i.jsx)(n.code,{children:"PlutusTx.Blueprint.TH.unstableMakeIsDataSchema"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["(This way ",(0,i.jsx)(n.code,{children:"HasBlueprintSchema"})," instance is guaranteed to correspond to the ",(0,i.jsx)(n.code,{children:"ToData"})," and ",(0,i.jsx)(n.code,{children:"FromData"})," instances which are derived with it.)"]}),"\n",(0,i.jsx)(n.p,{children:"Here is an example:"}),"\n",(0,i.jsx)(a,{file:"Example/Cip57/Blueprint/Main.hs",language:"haskell",title:"TH-derived HasBlueprintSchema instances",start:"-- BEGIN makeIsDataSchemaIndexed",end:"-- END makeIsDataSchemaIndexed"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"defining-a-validator-blueprint",children:"Defining a validator blueprint"}),"\n",(0,i.jsx)(n.p,{children:"Finally, we need to define a validator blueprint for each validator used in the contract."}),"\n",(0,i.jsx)(n.p,{children:"Our contract can contain one or more validators. For each one we need to provide a description as a value of the following type:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"data ValidatorBlueprint (referencedTypes :: [Type]) = MkValidatorBlueprint\n  { validatorTitle       :: Text\n  -- ^ A short and descriptive name for the validator.\n  , validatorDescription :: Maybe Text\n  -- ^ An informative description of the validator.\n  , validatorRedeemer    :: ArgumentBlueprint referencedTypes\n  -- ^ A description of the redeemer format expected by this validator.\n  , validatorDatum       :: Maybe (ArgumentBlueprint referencedTypes)\n  -- ^ A description of the datum format expected by this validator.\n  , validatorParameters  :: [ParameterBlueprint referencedTypes]\n  -- ^ A list of parameters required by the script.\n  , validatorCompiled    :: Maybe CompiledValidator\n  -- ^ A full compiled and CBOR-encoded serialized flat script together with its hash.\n  }\n  deriving stock (Show, Eq, Ord)\n"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In our example, this would be:"}),"\n",(0,i.jsx)(a,{file:"Example/Cip57/Blueprint/Main.hs",language:"haskell",title:"validator blueprint declaration",start:"-- BEGIN validator blueprint declaration",end:"-- END validator blueprint declaration"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"definitionRef"})," function is used to reference a schema definition of a given type.\nIt is smart enough to discover the schema definition from the ",(0,i.jsx)(n.code,{children:"referencedType"})," list and fails to compile if the referenced type is not included."]}),"\n",(0,i.jsxs)(n.p,{children:["If you want to provide validator code with its hash, you can use the ",(0,i.jsx)(n.code,{children:"compiledValidator"})," function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"compiledValidator\n  :: PlutusVersion\n  -- ^ Plutus version (e.g. `PlutusV3`) to calculate the hash of the validator code.\n  -> ByteString\n  -- ^ The compiled validator code.\n  -> CompiledValidator\n"})}),"\n",(0,i.jsx)(n.h2,{id:"writing-the-blueprint-to-a-file",children:"Writing the blueprint to a file"}),"\n",(0,i.jsx)(n.p,{children:"With all the pieces in place, we can now write the blueprint to a file:"}),"\n",(0,i.jsx)(a,{file:"Example/Cip57/Blueprint/Main.hs",language:"haskell",title:"write blueprint to file",start:"-- BEGIN write blueprint to file",end:"-- END write blueprint to file"}),"\n",(0,i.jsx)(n.h2,{id:"annotations",children:"Annotations"}),"\n",(0,i.jsxs)(n.p,{children:["Any ",(0,i.jsx)(n.a,{href:"https://cips.cardano.org/cip/CIP-0057",children:"CIP-0057"})," blueprint type definition may include ",(0,i.jsx)(n.a,{href:"https://cips.cardano.org/cip/CIP-0057#for-any-data-type",children:"optional keywords"})," to provide additional information:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"title"}),"\n",(0,i.jsx)(n.li,{children:"description"}),"\n",(0,i.jsx)(n.li,{children:"$comment"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"It's possible to add these keywords to a Blueprint type definition by annotating the Haskell type from which it's derived with a corresponding annotation:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"SchemaTitle"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"SchemaDescription"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"SchemaComment"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For example, to add a title and description to the ",(0,i.jsx)(n.code,{children:"MyParams"})," type, we can use the ",(0,i.jsx)(n.code,{children:"SchemaTitle"})," and ",(0,i.jsx)(n.code,{children:"SchemaDescription"})," annotations:"]}),"\n",(0,i.jsx)(a,{file:"Example/Cip57/Blueprint/Main.hs",language:"haskell",title:"MyParams annotations",start:"-- BEGIN MyParams annotations",end:"-- END MyParams annotations"}),"\n",(0,i.jsx)(n.p,{children:"These annotations result in the following JSON schema definition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "title": "Title for the MyParams definition",\n  "description": "Description for the MyParams definition",\n  "dataType": "constructor",\n  "fields": [\n    { "$ref": "#/definitions/Bool" },\n    { "$ref": "#/definitions/Integer" }\n  ],\n  "index": 0\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"For sum-types, it's possible to annotate constructors:"}),"\n",(0,i.jsx)(a,{file:"Example/Cip57/Blueprint/Main.hs",language:"haskell",title:"MyRedeemer annotations",start:"-- BEGIN MyRedeemer annotations",end:"-- END MyRedeemer annotations"}),"\n",(0,i.jsx)(n.p,{children:"These annotations result in the following JSON schema definition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "oneOf": [\n    {\n      "$comment": "Left redeemer",\n      "dataType": "constructor",\n      "fields": [],\n      "index": 0\n    },\n    {\n      "$comment": "Right redeemer",\n      "dataType": "constructor",\n      "fields": [],\n      "index": 1\n    }\n  ]\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["It is also possible to annotate a validator's parameter or argument ",(0,i.jsx)(n.strong,{children:"type"})," (as opposed to annotating ",(0,i.jsx)(n.em,{children:"constructors"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:'{-# ANN type MyParams (SchemaTitle "Example parameter title") #-}\n{-# ANN type MyRedeemer (SchemaTitle "Example redeemer title") #-}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Then, instead of providing them literally:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:'myValidator =\n  MkValidatorBlueprint\n    { ... elided\n    , validatorParameters =\n        [ MkParameterBlueprint\n            { parameterTitle = Just "My Validator Parameters"\n            , parameterDescription = Just "Compile-time validator parameters"\n            , parameterPurpose = Set.singleton Spend\n            , parameterSchema = definitionRef @MyParams\n            }\n        ]\n    , validatorRedeemer =\n        MkArgumentBlueprint\n          { argumentTitle = Just "My Redeemer"\n          , argumentDescription = Just "A redeemer that does something awesome"\n          , argumentPurpose = Set.fromList [Spend, Mint]\n          , argumentSchema = definitionRef @MyRedeemer\n          }\n    , ... elided\n    }\n'})}),"\n",(0,i.jsx)(n.p,{children:"Use TH to have a more concise version:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-haskell",children:"myValidator =\n  MkValidatorBlueprint\n    { ... elided\n    , validatorParameters =\n        [ $(deriveParameterBlueprint ''MyParams (Set.singleton Purpose.Spend)) ]\n    , validatorRedeemer =\n        $(deriveArgumentBlueprint ''MyRedeemer (Set.fromList [Purpose.Spend, Purpose.Mint]))\n    , ... elided\n    }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"resulting-full-blueprint-example",children:"Resulting full blueprint example"}),"\n",(0,i.jsxs)(n.p,{children:["Here is the full ",(0,i.jsx)(n.a,{href:"https://cips.cardano.org/cip/CIP-0057",children:"CIP-0057"})," blueprint produced by this example: ",(0,i.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(385).A+"",children:"plutus.json"})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["\ud83d\udccc"," ",(0,i.jsx)(n.strong,{children:"NOTE"})]}),"\n",(0,i.jsxs)(n.p,{children:["You can find a more elaborate example of a contract blueprint in the ",(0,i.jsx)(n.code,{children:"Blueprint.Tests"})," module of the Plutus repository."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},385:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/files/plutus-8c18ca429a27f8c35253e4cc86b708d9.json"},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var i=t(6540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);