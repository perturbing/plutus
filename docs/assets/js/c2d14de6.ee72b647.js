"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9088],{5725:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var i=t(4848),s=t(8453);const r={sidebar_position:25},o="Special Functions and Types",l={id:"using-plutus-tx/special-functions-and-types",title:"Special Functions and Types",description:"Normally, the Plutus Tx compiler compiles a Haskell identifier by obtaining and compiling its definition (also known as unfolding), and creating a term binding in PIR, an intermediate representation used by the Plutus Tx compiler.",source:"@site/docs/using-plutus-tx/special-functions-and-types.md",sourceDirName:"using-plutus-tx",slug:"/using-plutus-tx/special-functions-and-types",permalink:"/docs/using-plutus-tx/special-functions-and-types",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/doc/docusaurus/docs/using-plutus-tx/special-functions-and-types.md",tags:[],version:"current",sidebarPosition:25,frontMatter:{sidebar_position:25},sidebar:"tutorialSidebar",previous:{title:"GHC Extensions, Flags and Pragmas",permalink:"/docs/using-plutus-tx/extensions-flags-pragmas"},next:{title:"Inspecting Compilation and Compiled Code",permalink:"/docs/using-plutus-tx/inspecting"}},a={},c=[{value:"Builtin Functions and Types",id:"builtin-functions-and-types",level:2},{value:"<code>PlutusTx.Bool.&amp;&amp;</code> and <code>PlutusTx.Bool.||</code>",id:"plutustxbool-and-plutustxbool",level:2},{value:"<code>IsString</code> Instances",id:"isstring-instances",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"special-functions-and-types",children:"Special Functions and Types"}),"\n",(0,i.jsx)(n.p,{children:"Normally, the Plutus Tx compiler compiles a Haskell identifier by obtaining and compiling its definition (also known as unfolding), and creating a term binding in PIR, an intermediate representation used by the Plutus Tx compiler.\nTypes are compiled in a similar manner, by compiling the type's definition and generating a type or datatype binding in PIR."}),"\n",(0,i.jsx)(n.p,{children:"However, there are certain special functions and types that aren't compiled this way.\nRather, they are handled specially and directly converted to terms or types in PIR.\nIt is useful to be aware of these, as these functions and types work differently than regular user-defined functions and types, and cannot be defined in user space."}),"\n",(0,i.jsx)(n.h2,{id:"builtin-functions-and-types",children:"Builtin Functions and Types"}),"\n",(0,i.jsxs)(n.p,{children:["There are a number of builtin functions and builtin types in UPLC.\nThe list of builtin functions and types can be found in the ",(0,i.jsx)(n.a,{href:"https://plutus.cardano.intersectmbo.org/resources/plutus-core-spec.pdf",children:"Plutus Core Specification"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["In ",(0,i.jsx)(n.a,{href:"https://plutus.cardano.intersectmbo.org/haddock/latest/plutus-tx/PlutusTx-Builtins-Internal.html",children:(0,i.jsx)(n.code,{children:"PlutusTx.Builtins.Internal"})}),", functions marked ",(0,i.jsx)(n.code,{children:"OPAQUE"})," are directly converted to the corresponding builtin function.\nFor instance, ",(0,i.jsx)(n.code,{children:"PlutusTx.Builtins.Internal.addInteger"})," is converted to UPLC term ",(0,i.jsx)(n.code,{children:"(builtin addInteger)"}),".\nUsing the ",(0,i.jsx)(n.code,{children:"OPAQUE"})," pragma prevents GHC from inlining these functions, allowing the Plutus Tx compiler to determine where exactly they are invoked, and compile them appropriately."]}),"\n",(0,i.jsx)(n.p,{children:"Builtin types are handled similarly: rather than compiling their definition, they are directly converted to builtin types in PIR.\nIn UPLC, most types are erased, but constants remain tagged with the corresponding builtin types."}),"\n",(0,i.jsxs)(n.p,{children:["Since functions in ",(0,i.jsx)(n.code,{children:"PlutusTx.Builtins.Internal"})," correspond to builtin functions that operate on builtin types, it's usually preferable to use functions in ",(0,i.jsx)(n.a,{href:"https://plutus.cardano.intersectmbo.org/haddock/latest/plutus-tx/PlutusTx-Builtins.html",children:(0,i.jsx)(n.code,{children:"PlutusTx.Builtins"})}),".\nThese functions wrap their counterparts in the ",(0,i.jsx)(n.code,{children:"Internal"})," module, and operate on standard Haskell types whenever possible, which are often more convenient."]}),"\n",(0,i.jsxs)(n.p,{children:["Aside from ",(0,i.jsx)(n.code,{children:"BuiltinInteger"}),", which is an alias for ",(0,i.jsx)(n.code,{children:"Integer"}),", other builtin types are distinct from their corresponding Haskell types.\nNot all of these Haskell types can be used in Plutus Tx.\nFor instance, ",(0,i.jsx)(n.code,{children:"String"})," and ",(0,i.jsx)(n.code,{children:"ByteString"})," are not supported, whereas regular algebraic data types like ",(0,i.jsx)(n.code,{children:"Bool"}),", lists and pairs are supported."]}),"\n",(0,i.jsxs)(n.h2,{id:"plutustxbool-and-plutustxbool",children:[(0,i.jsx)(n.code,{children:"PlutusTx.Bool.&&"})," and ",(0,i.jsx)(n.code,{children:"PlutusTx.Bool.||"})]}),"\n",(0,i.jsxs)(n.p,{children:["In ",(0,i.jsx)(n.a,{href:"https://plutus.cardano.intersectmbo.org/haddock/latest/plutus-tx/PlutusTx-Bool.html",children:(0,i.jsx)(n.code,{children:"PlutusTx.Bool"})}),", the ",(0,i.jsx)(n.code,{children:"&&"})," and ",(0,i.jsx)(n.code,{children:"||"})," operators are handled specially in the plugin to ensure they can short-circuit.\nIn most strict languages, these operators are special and cannot be defined by users, which is also the case for Plutus Tx."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that in regular Haskell, ",(0,i.jsx)(n.code,{children:"&&"})," and ",(0,i.jsx)(n.code,{children:"||"})," are ",(0,i.jsx)(n.em,{children:"not"})," special, as Haskell supports non-strict function applications (and it is the default behavior)."]}),"\n",(0,i.jsxs)(n.h2,{id:"isstring-instances",children:[(0,i.jsx)(n.code,{children:"IsString"})," Instances"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://hackage.haskell.org/package/base/docs/Data-String.html#t:IsString",children:(0,i.jsx)(n.code,{children:"IsString"})})," is a type class from ",(0,i.jsx)(n.code,{children:"base"}),", and can be used along with the ",(0,i.jsx)(n.code,{children:"OverloadedStrings"})," language extension to convert string literals to types other than ",(0,i.jsx)(n.code,{children:"String"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Most ",(0,i.jsx)(n.code,{children:"IsString"})," instances are unsupported by the Plutus Tx compiler, other than a few special cases.\nAt present, it provides support for ",(0,i.jsx)(n.code,{children:"BuiltinString"})," and ",(0,i.jsx)(n.code,{children:"BuiltinByteString"}),", with the caveat that the ",(0,i.jsx)(n.code,{children:"fromString"})," method must be applied to a string literal."]}),"\n",(0,i.jsxs)(n.p,{children:["As previously noted, ",(0,i.jsx)(n.code,{children:"String"})," and ",(0,i.jsx)(n.code,{children:"ByteString"})," are not available in Plutus Tx, so you'll need to use ",(0,i.jsx)(n.code,{children:"BuiltinString"})," or ",(0,i.jsx)(n.code,{children:"BulitinByteString"}),".\nThis lets you write ",(0,i.jsx)(n.code,{children:'"hello" :: BuiltinString'})," and ",(0,i.jsx)(n.code,{children:'"world" :: BuiltinByteString'})," in Plutus Tx, which is quite convenient."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);