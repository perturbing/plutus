"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1138],{5624:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>r,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var t=n(4848),i=n(8453);const o={sidebar_position:20},a="GHC Extensions, Flags and Pragmas",l={id:"using-plutus-tx/extensions-flags-pragmas",title:"GHC Extensions, Flags and Pragmas",description:"Plutus Tx is a subset of Haskell and is compiled to Untyped Plutus Core by the Plutus Tx compiler, a GHC (Glasgow Haskell Compiler) plugin.",source:"@site/docs/using-plutus-tx/extensions-flags-pragmas.md",sourceDirName:"using-plutus-tx",slug:"/using-plutus-tx/extensions-flags-pragmas",permalink:"/docs/using-plutus-tx/extensions-flags-pragmas",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/doc/docusaurus/docs/using-plutus-tx/extensions-flags-pragmas.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{sidebar_position:20},sidebar:"tutorialSidebar",previous:{title:"Differences From Haskell",permalink:"/docs/using-plutus-tx/differences-from-haskell"},next:{title:"Special Functions and Types",permalink:"/docs/using-plutus-tx/special-functions-and-types"}},r={},c=[{value:"Extensions",id:"extensions",level:3},{value:"Flags",id:"flags",level:3},{value:"Pragmas",id:"pragmas",level:3}];function d(e){const s={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"ghc-extensions-flags-and-pragmas",children:"GHC Extensions, Flags and Pragmas"}),"\n",(0,t.jsx)(s.p,{children:"Plutus Tx is a subset of Haskell and is compiled to Untyped Plutus Core by the Plutus Tx compiler, a GHC (Glasgow Haskell Compiler) plugin."}),"\n",(0,t.jsx)(s.p,{children:"In order to ensure the success and correct compilation of Plutus Tx programs, all Plutus Tx modules (that is, Haskell modules that contain code to be compiled by the Plutus Tx compiler) should use the following GHC extensions, flags and pragmas."}),"\n",(0,t.jsx)(s.h3,{id:"extensions",children:"Extensions"}),"\n",(0,t.jsxs)(s.p,{children:["Plutus Tx modules should use the ",(0,t.jsx)(s.code,{children:"Strict"})," extension: :"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    {-# LANGUAGE Strict #-}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["As mentioned in ",(0,t.jsx)(s.a,{href:"/docs/using-plutus-tx/differences-from-haskell",children:"Differences from Haskell"}),", function applications in Plutus Tx are always strict, while bindings can be strict or non-strict.\nIn addition, the UPLC evaluator does not perform lazy evaluation, meaning a non-strict binding is evaluated as many times as it is used.\nGiven these facts, making let bindings strict by default has the following advantages:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["It makes let bindings and function applications semantically equivalent. For example, ",(0,t.jsx)(s.code,{children:"let x = 3 + 4 in 42"})," has the same semantics as ",(0,t.jsx)(s.code,{children:"(\\x -> 42) (3 + 4)"}),".\nThis is what one would come to expect, as it is the case in most other programming languages, regardless of whether the language is strict or non-strict."]}),"\n",(0,t.jsxs)(s.li,{children:["Using non-strict bindings can cause an expression to be inadvertently evaluated for an unbounded number of times.\nConsider ",(0,t.jsx)(s.code,{children:"let x = <expensive> in \\y -> x + y"}),".\nIf ",(0,t.jsx)(s.code,{children:"x"})," is non-strict, ",(0,t.jsx)(s.code,{children:"<expensive>"})," will be evaluated every time ",(0,t.jsx)(s.code,{children:"\\y -> x + y"})," is applied to an argument, which means it can be evaluated 0 times, 1 time, 2 times, or any number of times (this is not the case if lazy evaluation was employed).\nOn the other hand, if ",(0,t.jsx)(s.code,{children:"x"})," is strict, it is always evaluated once, which is at most one more time than what is necessary."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"flags",children:"Flags"}),"\n",(0,t.jsxs)(s.p,{children:["GHC has a variety of optimization flags, many of which are on by default.\nAlthough Plutus Tx is, syntactically, a subset of Haskell, it has different semantics and a different evaluation strategy (Haskell: non-strict semantics, call by need; Plutus Tx: strict semantics, call by value). As a result, some GHC optimizations are not helpful for Plutus Tx programs, and can even be harmful, in the sense that it can make Plutus Tx programs less efficient, or fail to be compiled.\nAn example is the full laziness optimization, controlled by GHC flag ",(0,t.jsx)(s.code,{children:"-ffull-laziness"}),", which floats let bindings out of lambdas whenever possible.\nSince Untyped Plutus Core does not employ lazy evaluation, the full laziness optimization is usually not beneficial, and can sometimes make a Plutus Tx program more expensive.\nConversely, some GHC features must be turned on in order to ensure Plutus Tx programs are compiled successfully."]}),"\n",(0,t.jsx)(s.p,{children:"All Plutus Tx modules should use the following GHC flags:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    -fno-ignore-interface-pragmas\n    -fno-omit-interface-pragmas\n    -fno-full-laziness\n    -fno-spec-constr\n    -fno-specialise\n    -fno-strictness\n    -fno-unbox-strict-fields\n    -fno-unbox-small-strict-fields\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"-fno-ignore-interface-pragmas"})," and ",(0,t.jsx)(s.code,{children:"-fno-omit-interface-pragmas"})," ensure unfoldings of Plutus Tx functions are available.\nThe rest are GHC optimizations that are generally bad for Plutus Tx, and should thus be turned off."]}),"\n",(0,t.jsx)(s.p,{children:"These flags can be specified either in a Haskell module, for example:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"    {-# OPTIONS_GHC -fno-ignore-interface-pragmas #-}\n"})}),"\n",(0,t.jsxs)(s.p,{children:["or in a build file.\nFor example, if your project is built using Cabal, you can add the flags to the ",(0,t.jsx)(s.code,{children:".cabal"})," files, like so:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ghc-options:\n  -fno-ignore-interface-pragmas\n"})}),"\n",(0,t.jsxs)(s.blockquote,{children:["\n",(0,t.jsxs)(s.p,{children:["\ud83d\udccc"," ",(0,t.jsx)(s.strong,{children:"NOTE"})]}),"\n",(0,t.jsxs)(s.p,{children:["This section only covers GHC flags, not Plutus Tx compiler flags.\nA number of options can be passed to the Plutus Tx compiler.\nSee ",(0,t.jsx)(s.a,{href:"/docs/delve-deeper/plutus-tx-compiler-options",children:"Plutus Tx Compiler Options"})," for details."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"pragmas",children:"Pragmas"}),"\n",(0,t.jsxs)(s.p,{children:["All functions and methods should have the ",(0,t.jsx)(s.code,{children:"INLINEABLE"})," pragma (not the ",(0,t.jsx)(s.code,{children:"INLINE"})," pragma, which should generally be avoided), so that their unfoldings are made available to the Plutus Tx compiler."]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"-fexpose-all-unfoldings"})," flag also makes GHC expose all unfoldings, but unfoldings exposed this way can be more optimized than unfoldings exposed via ",(0,t.jsx)(s.code,{children:"INLINEABLE"}),".\nIn general, we do not want GHC to perform optimizations, since GHC optimizes a program based on the assumption that it has non-strict semantics and is evaluated lazily (call by need), which is not true for Plutus Tx programs.\nTherefore, ",(0,t.jsx)(s.code,{children:"INLINEABLE"})," is preferred over ",(0,t.jsx)(s.code,{children:"-fexpose-all-unfoldings"}),", even though the latter is simpler."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"-fexpose-all-unfoldings"})," can be useful for functions that are generated by GHC and do not have the ",(0,t.jsx)(s.code,{children:"INLINEABLE"})," pragma.\n",(0,t.jsx)(s.code,{children:"-fspecialise"})," and ",(0,t.jsx)(s.code,{children:"-fspec-constr"})," are two examples of optimizations that can generate such functions.\nThe most reliable solution, however, is to simply turn these optimizations off.\nAnother option is to bump ",(0,t.jsx)(s.code,{children:"-funfolding-creation-threshold"})," to make it more likely for GHC to retain unfoldings for functions without the ",(0,t.jsx)(s.code,{children:"INLINEABLE"})," pragma.\n",(0,t.jsx)(s.code,{children:"-fexpose-all-unfoldings"})," should be used as a last resort."]})]})}function u(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>l});var t=n(6540);const i={},o=t.createContext(i);function a(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);