"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[8329],{9340:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var a=t(4848),s=t(8453);const i={sidebar_position:1},o="Overview of Languages Compiling to UPLC",r={id:"delve-deeper/languages",title:"Overview of Languages Compiling to UPLC",description:"Untyped Plutus Core (UPLC) is the assembly-like language that runs in Cardano nodes for transaction validation.",source:"@site/docs/delve-deeper/languages.md",sourceDirName:"delve-deeper",slug:"/delve-deeper/languages",permalink:"/docs/delve-deeper/languages",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/doc/docusaurus/docs/delve-deeper/languages.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Delve Deeper",permalink:"/docs/category/delve-deeper"},next:{title:"Haddock Documentation",permalink:"/docs/delve-deeper/haddock-documentation"}},l={},d=[{value:"Standalone DSLs",id:"standalone-dsls",level:2},{value:"Embedded DSLs",id:"embedded-dsls",level:2},{value:"Subsets of Existing Languages",id:"subsets-of-existing-languages",level:2},{value:"List of Existing Languages",id:"list-of-existing-languages",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",section:"section",sup:"sup",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"overview-of-languages-compiling-to-uplc",children:"Overview of Languages Compiling to UPLC"}),"\n",(0,a.jsxs)(n.p,{children:["Untyped Plutus Core (UPLC) is the assembly-like language that runs in Cardano nodes for transaction validation.\nThe Cardano node ships with a UPLC evaluator, which is a ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/CEK_Machine",children:"CEK machine"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"UPLC is a low-level programming language, and is not intended to be written or modified by hand.\nBesides Plutus Tx, several other high-level languages are designed to target UPLC.\nThese languages can be grouped into three categories:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Standalone DSLs, which are entirely new languages"}),"\n",(0,a.jsx)(n.li,{children:"DSLs embedded in existing general-purpose programming languages"}),"\n",(0,a.jsx)(n.li,{children:"Subsets of existing general-purpose programming languages"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"These are also the three common strategies for creating DSLs in general, not limited to blockchains or Cardano.\nEach strategy comes with its own benefits and drawbacks, which we'll discuss next."}),"\n",(0,a.jsx)(n.h2,{id:"standalone-dsls",children:"Standalone DSLs"}),"\n",(0,a.jsx)(n.p,{children:"A standalone DSL is a new language with its own syntax and semantics.\nBy crafting a new language from scratch, you avoid inheriting the limitations and complexities of existing languages, allowing you to tailor-make it to be as simple, intuitive and elegant as possible to program for the specific domain it targets."}),"\n",(0,a.jsx)(n.p,{children:"On the other hand, standalone DSLs have some disadvantages.\nFirst, designing and implementing them can be challenging.\nNot only must the syntax and semantics be created from scratch, but you also need to build all necessary compiler components, tooling, and a library ecosystem from the ground up.\nThis can be a formidable task, as developing, testing, and maintaining compilers and tooling, along with establishing and maintaining a library ecosystem, require substantial efforts, particularly with the addition of new language features over time."}),"\n",(0,a.jsx)(n.p,{children:"Second, users will need to adopt a new programming language and incorporate it into their existing tech stacks.\nThis can present a considerable challenge, as it involves a learning curve, increased cognitive load, and the necessity to introduce and manage additional tools."}),"\n",(0,a.jsx)(n.h2,{id:"embedded-dsls",children:"Embedded DSLs"}),"\n",(0,a.jsx)(n.p,{children:"An embedded DSL (commonly referred to as an eDSL) generally takes the form of a library in a host programming language.\nFunctional languages such as Haskell are particularly well-suited for hosting eDSLs, as the implementation of an eDSL largely involves functions that construct and transform abstract syntax trees (ASTs)."}),"\n",(0,a.jsx)(n.p,{children:"Embedded DSLs can be much easier than standalone DSLs to develop, and to integrate into projects that already use the host language.\nEmbedded DSLs, however, come with the drawback that the complexity of constructing and manipulating ASTs are exposed to the users.\nWhen using an embedded DSL, you are essentially writing programs that create and manage ASTs, rather than straightforward code."}),"\n",(0,a.jsxs)(n.p,{children:["Take, for instance, a program that accepts two integers as input, and checks if the first is less than the second.\nNormally, you would write a function of type ",(0,a.jsx)(n.code,{children:"Integer -> Integer -> Bool"}),", which takes two integers and returns a boolean.\nHowever, when working with an eDSL, your program might have a type like ",(0,a.jsx)(n.code,{children:"AST Integer -> AST Integer -> AST Bool"}),", which takes two ASTs that evaluate to integers, combines them, and yields a larger AST that evaluates to a boolean.\nThe complexity increases further if the comparison is polymorphic, since it is unlikely that the usual method of writing polymorphic functions (such as Haskell's ",(0,a.jsx)(n.code,{children:"Ord"})," instance) can be reused.\nLike standalone DSLs, this also introduces additional learning curves and cognitive load, though for a different reason."]}),"\n",(0,a.jsx)(n.p,{children:"Another disadvantage of eDSLs is that it is harder, compared to the other two approaches, to produce readable target code or accurate source mappings for debuggers.\nThis stems from the nature of eDSLs, which are libraries that construct and manipulate ASTs.\nSince they do not have direct access to the host language's ASTs, it can be challenging to retrieve information related to the source code, such as variable names, module names and code locations."}),"\n",(0,a.jsxs)(n.p,{children:['The eDSLs described above fall under the category of "deep embedding".\nThere\'s another category of eDSLs, called "shallow embedding", which, unlikely deep embedding, does not construct intermediate ASTs.\nInstead, shallow embedding involves using overloaded functions.\nFor example, a DSL designed as a shallow embedding for working with databases might include operations such as ',(0,a.jsx)(n.code,{children:"createTable"}),", ",(0,a.jsx)(n.code,{children:"getItem"}),", and ",(0,a.jsx)(n.code,{children:"putItem"}),".\nThese functions are overloaded, allowing them to work with various database implementations, including mock databases for testing purposes.\nSuch overloaded functions are typically defined using typeclasses in functional languages, or interfaces/traits in object-oriented languages."]}),"\n",(0,a.jsxs)(n.p,{children:["While it is valid to call shallow embeddings ",(0,a.jsx)(n.em,{children:"languages"}),", it is a bit of a stretch.\nOverloaded functions are widespread in everyday programming, and are not usually regarded as languages due to the absence of ASTs.\nMoreover, shallow embedding is less fitting when the eDSL targets a lower level language like UPLC, as constructing ASTs for UPLC will still be necessary.\nAll existing eDSLs targeting UPLC are examples of deep embeddings."]}),"\n",(0,a.jsx)(n.h2,{id:"subsets-of-existing-languages",children:"Subsets of Existing Languages"}),"\n",(0,a.jsxs)(n.p,{children:["Similar to eDSLs, this approach can be particularly appealing if your team or project is already using the host language.\nIt allows for even greater reuse of existing functions, types and idioms from the hosting language, compared to eDSLs.\nFor instance, a program that tests whether one integer is less than another can retain the type ",(0,a.jsx)(n.code,{children:"forall a. Ord a => a -> a -> Bool"}),", and can even reuse the ",(0,a.jsx)(n.code,{children:"<"})," operator in the hosting language's standard library",(0,a.jsx)(n.sup,{children:(0,a.jsx)(n.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),"."]}),"\n",(0,a.jsx)(n.p,{children:"This is achieved by leveraging the host language's compiler frontend, which might include lexer, parser, type checker, AST and optimization passes, while developing a custom backend for the new language.\nBy reusing the host language's ASTs, programs maintain simple and regular types without the need for custom AST construction, which is often necessary in eDSLs."}),"\n",(0,a.jsxs)(n.p,{children:["A case in point is Plutus Tx, which is a subset of Haskell, and its compiler is a GHC plugin.\nIt reuses GHC components like the parser and type checker, and transforms GHC Core (GHC's intermediate representation) into UPLC.\nAlternatively, meta-programming methods can be used to access and manipulate the host language's AST, such as quotes and splices",(0,a.jsx)(n.sup,{children:(0,a.jsx)(n.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Nonetheless, developing a new language as a subset of an existing language presents several challenges.\nThe compiler components of the host language are most likely not tailored for the new language, and making them work for the new language can be difficult.\nFor example, optimizations that work well for the host language might not be effective or valid for the new language.\nAdditionally, the desugaring process might transform code in such a way that it no longer fits within the supported subset, causing issues with the new language\u2019s compiler."}),"\n",(0,a.jsx)(n.p,{children:"Furthermore, complications arise when the new language and the host language do not exactly agree on semantics or evaluation strategies.\nThis disparity can lead to behaviors where the same code might act differently when compiled and executed in the host language versus the new language.\nIt can also result in idioms that work well in the host language being inappropriate for the new language.\nFor example, while guarded recursion is a useful idiom in Haskell, it might not be suitable for Plutus Tx due to Plutus Tx's use of call-by-value evaluation."}),"\n",(0,a.jsx)(n.p,{children:"Another drawback of using a subset of a language is that, determining whether a program conforms to the allowed subset typically doesn't happen at type checking time, but at target code generation time.\nThis not only delays error detection compared to eDSLs, but makes it harder to produce clear error messages, since by target code generation time, the AST may have already been transformed and optimized, obscuring its connection to the original source code."}),"\n",(0,a.jsx)(n.h2,{id:"list-of-existing-languages",children:"List of Existing Languages"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Language"}),(0,a.jsx)(n.th,{children:"Category"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Plutus Tx"}),(0,a.jsx)(n.td,{children:"Subset of Haskell"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"https://aiken-lang.org/",children:"Aiken"})}),(0,a.jsx)(n.td,{children:"Standalone DSL"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"https://github.com/HeliosLang/compiler",children:"Helios"})}),(0,a.jsx)(n.td,{children:"Standalone DSL"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"https://github.com/OpShin/opshin",children:"OpShin"})}),(0,a.jsx)(n.td,{children:"Subset of Python"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"https://github.com/HarmonicLabs/plu-ts",children:"plu-ts"})}),(0,a.jsx)(n.td,{children:"DSL embedded in TypeScript"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"https://github.com/Plutonomicon/plutarch-plutus",children:"Plutarch"})}),(0,a.jsx)(n.td,{children:"DSL embedded in Haskell"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"https://github.com/nau/scalus",children:"Scalus"})}),(0,a.jsx)(n.td,{children:"Subset of Scala"})]})]})]}),"\n",(0,a.jsx)(n.hr,{}),"\n","\n",(0,a.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,a.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{id:"user-content-fn-1",children:["\n",(0,a.jsxs)(n.p,{children:["This statement is not entirely true for Plutus Tx, a subset of Haskell.\nDue to certain GHC-specific technical limitations, it can't easily reuse many functions and operations from the ",(0,a.jsx)(n.code,{children:"base"})," library, so it ships with its own standard library instead.\nNevertheless, the ",(0,a.jsx)(n.code,{children:"<"})," operator in Plutus Tx's standard library still has the type ",(0,a.jsx)(n.code,{children:"Integer -> Integer -> Bool"}),". ",(0,a.jsx)(n.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{id:"user-content-fn-2",children:["\n",(0,a.jsxs)(n.p,{children:["For further reading, check out ",(0,a.jsx)(n.a,{href:"https://homepages.inf.ed.ac.uk/wadler/topics/qdsl.html",children:(0,a.jsx)(n.em,{children:"Everything old is new again: Quoted Domain Specific Languages"})}),". ",(0,a.jsx)(n.a,{href:"#user-content-fnref-2","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var a=t(6540);const s={},i=a.createContext(s);function o(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);